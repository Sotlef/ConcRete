#include "Zeni/Rete/Parser.hpp"

#include <iostream>

#define TAO_PEGTL_NAMESPACE Zeni_Rete_PEGTL

#include "tao/pegtl.hpp"

namespace Zeni {

  namespace Rete {

    using namespace tao::Zeni_Rete_PEGTL;

    class Parser_Pimpl : public std::enable_shared_from_this<Parser_Pimpl> {

      struct line_comment
        : until< eolf > {};

      struct list;

      struct list_comment
        : if_must< at< one< '(' >, disable< list > > > {};

      struct comment
        : if_must< one< '#' >, sor< list_comment, line_comment > > {};

      struct nothing
        : sor< space, comment > {};

      struct number
        : plus< digit > {};

      struct symbol
        : identifier {};

      struct atom
        : sor< number, symbol > {};

      struct anything;

      struct list
        : if_must< one< '(' >, until< one< ')' >, anything > > {};

      struct something
        : sor< atom, list > {};

      struct anything
        : sor< nothing, something > {};

      struct file
        : until< eof, anything > {};

    public:
      class simple_rule {
      public:
        template <typename Input>
        static bool match(const Input &input) {
          std::cout << "Match!" << std::endl;
        }
      };

      Parser_Pimpl() {

      }

      /// Decrements the output count, potentially resulting in cascading disconnects
      void parse_rule(const std::shared_ptr<Network> &network, const std::string &rule) {
        tao::Zeni_Rete_PEGTL::string_input<> input(rule, "Generated by Parser_Pimpl");
        tao::Zeni_Rete_PEGTL::parse<file>(input);
      }

    private:
      std::shared_ptr<Parser_Pimpl> m_impl;
    };

    Parser::Parser()
      : m_impl(std::make_shared<Parser_Pimpl>())
    {
    }

    void Parser::parse_rule(const std::shared_ptr<Network> &network, const std::string &rule) {
      m_impl->parse_rule(network, rule);
    }

  }

}
